#!/usr/bin/bash
# Loguard - Real-time Linux Login Alert to Telegram
# Version: 1.0.0
# GitHub: https://github.com/Nowafen/loguard

set -euo pipefail

VERSION="1.0.0"
INSTALL_DIR="/opt/loguard"
CONFIG_DIR="/etc/loguard"
CONFIG_FILE="$CONFIG_DIR/config.toml"
QUEUE_FILE="/var/log/loguard/pending_alerts.jsonl"
LOG_FILE="/var/log/loguard/alert.log"
PAM_FILES="/etc/pam.d/common-session /etc/pam.d/common-session-noninteractive /etc/pam.d/sshd /etc/pam.d/login /etc/pam.d/su /etc/pam.d/sudo /etc/pam.d/sudo-i /etc/pam.d/gdm-password"
VERSION_URL="https://raw.githubusercontent.com/Nowafen/loguard/refs/heads/main/version.txt"
REPO_URL="https://raw.githubusercontent.com/Nowafen/loguard/refs/heads/main/setting/loguard"

RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'; BLUE='\033[0;34m'; CYAN='\033[0;36m'; GRAY='\033[0;37m'; NC='\033[0m'

log() { echo -e "${BLUE}[Loguard]$NC $*"; }
success() { echo -e "${GREEN}Success$NC $*"; }
warn() { echo -e "${YELLOW}Warning$NC $*"; }
error() { echo -e "${RED}Error$NC $*"; }

check_root() {
    [[ $EUID -eq 0 ]] || { error "This command must be run as root (use sudo)"; exit 1; }
}

load_config() {
    [[ -f "$CONFIG_FILE" ]] || return 1
    source <(grep -E '^(bot_token|chat_id|hostname) *=' "$CONFIG_FILE" | sed 's/ *= */=/g' 2>/dev/null || true)
    BOT_TOKEN="${bot_token:-}"
    CHAT_ID="${chat_id:-}"
    HOSTNAME="${hostname:-}"
    return 0
}

save_config() {
    mkdir -p "$CONFIG_DIR"
    cat > "$CONFIG_FILE" <<EOF
# Loguard Configuration - Edited via wizard
bot_token = "$1"
chat_id   = "$2"
hostname  = "$3"
EOF
    success "Configuration saved to $CONFIG_FILE"
}

mask_token() {
    local token="$1"
    [[ -z "$token" ]] && echo "(not set)" && return
    local len=${#token}
    [[ $len -le 20 ]] && echo "$token" && return
    echo "${token:0:10}...${token: -8}"
}

edit_config_wizard() {
    clear
    echo -e "${CYAN}Loguard Configuration Wizard${NC}"
    echo -e "Config file: ${YELLOW}$CONFIG_FILE${NC}"
    echo

    load_config
    local current_token="$BOT_TOKEN"
    local current_chat="$CHAT_ID"
    local current_host="${HOSTNAME:-$(hostname)}"

    while true; do
        echo -e "${BLUE}Current Settings:${NC}"
        echo "1. Bot Token      → $(mask_token "$current_token")"
        echo "2. Chat ID        → ${current_chat:-"(not set)"}"
        echo "3. Hostname       → ${current_host:-"(auto: $(hostname)"}"
        echo
        echo -e "4. ${GREEN}Save & Exit${NC}"
        echo -e "5. ${RED}Exit without saving${NC}"
        echo
        read -p "Enter choice [1-5]: " choice
        echo

        case "$choice" in
            1)
                read -p "Enter Bot Token (or press Enter to keep current): " new_token
                [[ -n "$new_token" ]] && current_token="$new_token"
                success "Bot Token updated"
                ;;
            2)
                read -p "Enter Chat ID (or press Enter to keep current): " new_chat
                [[ -n "$new_chat" ]] && current_chat="$new_chat"
                success "Chat ID updated"
                ;;
            3)
                read -p "Enter custom hostname (or leave empty for auto): " new_host
                current_host="${new_host:-}"
                [[ -z "$current_host" ]] && echo "Hostname will use system default" || success "Hostname set to: $current_host"
                ;;
            4)
                echo -e "${YELLOW}Final Configuration:${NC}"
                echo "Bot Token : $(mask_token "$current_token")"
                echo "Chat ID   : ${current_chat:-"(empty!)"}"
                echo "Hostname  : ${current_host:-"(auto)"}"
                echo
                [[ -z "$current_token" || -z "$current_chat" ]] && {
                    warn "Bot Token and Chat ID are required!"
                    read -p "Continue anyway? [y/N]: " force
                    [[ ! "$force" =~ ^[Yy]$ ]] && continue
                }
                read -p "Apply changes? [Y/n]: " confirm
                [[ "$confirm" =~ ^[Nn]$ ]] && { warn "Changes discarded"; return; }
                save_config "$current_token" "$current_chat" "$current_host"
                echo
                success "Configuration applied successfully!"
                echo -e "${GREEN}Tip: Run 'sudo loguard test' to verify connection${NC}"
                return
                ;;
            5)
                warn "No changes saved"
                return
                ;;
            *) warn "Invalid option" ;;
        esac
        echo; read -p "Press Enter to continue..."
        clear
    done
}

# Enhanced: returns 0 if ANY PAM file has the rule, also populates global array
pam_status() {
    local found=0
    PAM_ACTIVE=()
    PAM_INACTIVE=()

    for f in $PAM_FILES; do
        [[ ! -f "$f" ]] && continue
        if grep -q "^session.*pam_exec\.so.*login-alert\.sh" "$f" 2>/dev/null; then
            PAM_ACTIVE+=("$f")
            ((found++))
        else
            PAM_INACTIVE+=("$f")
        fi
    done
    [[ $found -gt 0 ]]
}

count_pending() {
    [[ -f "$QUEUE_FILE" ]] && wc -l < "$QUEUE_FILE" 2>/dev/null || echo 0
}

last_alert() {
    [[ ! -f "$LOG_FILE" || ! -s "$LOG_FILE" ]] && { echo "Never"; return; }

    tail -1 "$LOG_FILE" | awk '
    /SENT/ {
        split($0, a, " ")
        printf "%s %s → %s@%s from %s", a[1], a[2], a[4], a[5], a[6]
        exit
    }
    /FAILED/ {
        split($0, a, " ")
        printf "%s %s → %s@%s (FAILED) from %s", a[1], a[2], a[4], a[5], a[6]
        exit
    }
    {
        print "Never"
    }'
}

telegram_test() {
    load_config || { error "Config not found or invalid"; return 1; }
    [[ -n "$BOT_TOKEN" && -n "$CHAT_ID" ]] || { error "bot_token or chat_id missing in config"; return 1; }
    local msg="*Loguard Test*%0AHost: <code>$(hostname)</code>%0ATime: <code>$(date '+%Y-%m-%d %H:%M:%S')</code>"
    local response
    response=$(curl -s -w "%{http_code}" -m 10 --data "chat_id=$CHAT_ID" --data "text=$msg" --data "parse_mode=HTML" \
       "https://api.telegram.org/bot$BOT_TOKEN/sendMessage" 2>/dev/null)
    local http_code="${response: -3}"
    if [[ "$http_code" == "200" ]]; then
        success "Test message sent! Check your Telegram."
    else
        error "Failed to send (HTTP $http_code). Check token/chat_id/internet."
    fi
}

show_status() {
    echo -e "${BLUE}Loguard Login Alert System${NC}"

    if pam_status; then
        echo -e "Status:      ${GREEN}Enabled${NC}              [OK]"
        echo -e "PAM Rules:   ${#PAM_ACTIVE[@]} active in ${#PAM_ACTIVE[@]} files"
        for f in "${PAM_ACTIVE[@]}"; do
            echo -e "             ${GREEN}Success${NC} $f"
        done
        [[ ${#PAM_INACTIVE[@]} -gt 0 ]] && for f in "${PAM_INACTIVE[@]}"; do
            echo -e "             ${GRAY}Skipped${NC} $f (not present or no rule)"
        done
    else
        echo -e "Status:      ${RED}Disabled${NC}             [Paused]"
        echo -e "PAM Rules:   No active configuration found"
    fi

    if load_config; then
        echo -e "Config:      $CONFIG_FILE          ${GREEN}Valid${NC}"
        [[ -n "$BOT_TOKEN" && -n "$CHAT_ID" ]] && echo -e "Telegram:    ${GREEN}Configured${NC}" || echo -e "Telegram:    ${RED}Not configured${NC}"
    else
        echo -e "Config:      ${RED}Missing or invalid${NC}"
    fi

    local pending=$(count_pending)
    [[ $pending -gt 0 ]] && echo -e "Queue:       ${YELLOW}$pending pending messages${NC}" || echo -e "Queue:       0 pending messages"
    echo -e "Last Alert:  $(last_alert)"
    echo -e "Version:     $VERSION"
}

show_logs() {
    local n=${1:-20}
    [[ $n -gt 200 ]] && n=200
    echo -e "${BLUE}Last $n login alerts (most recent first):${NC}"
    tail -n "$n" "$LOG_FILE" 2>/dev/null | tac | awk '
    /SENT/ { printf "%s %s | %-10s | %-8s | %-15s | %s\n", $1, $2, $4, $5, $6, $7; }
    /FAILED/ { printf "%s %s | %-10s | %-8s | %-15s | %s (FAILED)\n", $1, $2, $4, $5, $6, $7; }
    ' || echo "No alerts yet."
}

show_queue() {
    local count=$(count_pending)
    echo -e "${BLUE}Pending alerts: $count unsent message(s)${NC}"
    [[ $count -eq 0 ]] && return
    echo "Preview (first 5):"
    head -5 "$QUEUE_FILE" | jq -r '.msg // empty' | sed 's/%0A/\n/g; s/<[^>]*>//g' | nl -w2 -s': '
    [[ $count -gt 5 ]] && echo "... and $(($count - 5)) more."
}

enable_alerts() {
    local line="session optional pam_exec.so stdout $INSTALL_DIR/login-alert.sh"
    local added=0
    for f in $PAM_FILES; do
        [[ ! -f "$f" ]] && continue
        sed -i '/loguard\|login-alert\.sh/d' "$f"
        echo "# Loguard - Real-time login alerts" >> "$f"
        echo "$line" >> "$f"
        ((added++))
    done
    [[ $added -gt 0 ]] && success "Loguard enabled on $added PAM configurations" || warn "No PAM files were modified"
}

disable_alerts() {
    local removed=0
    for f in $PAM_FILES; do
        [[ ! -f "$f" ]] && continue
        if sed -i '/loguard\|login-alert\.sh/d' "$f" 2>/dev/null; then
            ((removed++))
        fi
    done
    [[ $removed -gt 0 ]] && success "Loguard disabled (removed from $removed files)" || warn "Loguard was not active"
}

clear_queue() {
    read -p "Clear all pending alerts? This cannot be undone [y/N]: " ans
    [[ "$ans" =~ ^[Yy]$ ]] || { echo "Aborted."; return; }
    : > "$QUEUE_FILE"
    success "Pending queue cleared."
}

update_loguard() {
    check_root
    echo -e "${YELLOW}Checking for updates...${NC}"
    local remote_version
    remote_version=$(curl -fsSL "$VERSION_URL" | grep -o '[0-9]\+\.[0-9]\+\.[0-9]\+' || echo "0.0.0")
    if [[ "$remote_version" > "$VERSION" ]]; then
        echo -e "${GREEN}New version available: $remote_version (current: $VERSION)${NC}"
        read -p "Update now? [Y/n]: " confirm
        [[ "$confirm" =~ ^[Nn]$ ]] && { echo "Update cancelled."; return; }
        curl -fsSL "$REPO_URL" -o "$INSTALL_DIR/loguard.new" && chmod +x "$INSTALL_DIR/loguard.new"
        mv "$INSTALL_DIR/loguard.new" "$INSTALL_DIR/loguard"
        sed -i "s/VERSION=\"$VERSION\"/VERSION=\"$remote_version\"/" "$INSTALL_DIR/loguard"
        ln -sf "$INSTALL_DIR/loguard" "/usr/local/bin/loguard"
        success "Updated to v$remote_version! Run: sudo loguard restart"
    else
        echo -e "${GREEN}You are up to date (v$VERSION).${NC}"
    fi
}

uninstall() {
    echo -e "${RED}WARNING: This will completely remove Loguard${NC}"
    read -p "Are you sure? [y/N]: " ans
    [[ "$ans" =~ ^[Yy]$ ]] || { echo "Uninstall cancelled."; exit 0; }
    for f in $PAM_FILES; do sed -i '/loguard\|login-alert\.sh/d' "$f" 2>/dev/null || true; done
    rm -rf "$INSTALL_DIR" "$CONFIG_DIR" "/var/log/loguard" "/usr/local/bin/loguard"
    success "Loguard has been completely removed. Goodbye!"
}

show_help() {
    cat << 'EOF'
Loguard v1.0.0 - Real-time Linux Login Alert to Telegram

Usage: loguard <command>

Commands:
  status      Show detailed status
  enable      Enable monitoring
  disable     Disable monitoring
  test        Send test message
  logs [n]    Show recent alerts
  queue       Show pending alerts
  edit        Configure via wizard
  update      Check for updates
  restart     Re-apply PAM rules
  uninstall   Remove Loguard
  help        Show this help

Config: /etc/loguard/config.toml
GitHub: https://github.com/Nowafen/loguard
EOF
}

main() {
    [[ -f "$INSTALL_DIR/loguard" ]] || { error "Loguard not installed properly."; exit 1; }
    mkdir -p "$CONFIG_DIR" "/var/log/loguard"

    case "${1:-}" in
        status|"")      show_status ;;
        enable)         check_root; enable_alerts ;;
        disable)        check_root; disable_alerts ;;
        test)           check_root; telegram_test ;;
        logs)           show_logs "${2:-}" ;;
        queue)          show_queue ;;
        clear-queue)    check_root; clear_queue ;;
        edit)           check_root; edit_config_wizard ;;
        update)         check_root; update_loguard ;;
        restart)        check_root; disable_alerts; enable_alerts ;;
        uninstall)      check_root; uninstall ;;
        help|-h)        show_help ;;
        *)              error "Unknown command: $1"; echo; show_help; exit 1 ;;
    esac
}

main "$@"